From 418ce4402939a0e449bdd3e8270bedf8e1013591 Mon Sep 17 00:00:00 2001
From: Min RK <benjaminrk@gmail.com>
Date: Tue, 26 Jul 2016 15:36:13 +0200
Subject: [PATCH] remove asyncio for Python 2

---
 zmq/asyncio.py             | 333 ---------------------------------------------
 zmq/auth/asyncio.py        |  50 -------
 zmq/tests/_test_asyncio.py | 203 ---------------------------
 zmq/tests/test_asyncio.py  |   6 -
 4 files changed, 592 deletions(-)
 delete mode 100644 zmq/asyncio.py
 delete mode 100644 zmq/auth/asyncio.py
 delete mode 100644 zmq/tests/_test_asyncio.py
 delete mode 100644 zmq/tests/test_asyncio.py

diff --git a/zmq/asyncio.py b/zmq/asyncio.py
deleted file mode 100644
index 9e5eaf1..0000000
--- zmq/asyncio.py
+++ /dev/null
@@ -1,333 +0,0 @@
-"""AsyncIO support for zmq
-
-Requires asyncio and Python 3.
-"""
-
-# Copyright (c) PyZMQ Developers.
-# Distributed under the terms of the Modified BSD License.
-# Derived from Python 3.5.1 selectors._BaseSelectorImpl, used under PSF License
-
-from collections import Mapping
-
-import zmq as _zmq
-from zmq.eventloop import future as _future
-
-# TODO: support trollius for Legacy Python? (probably not)
-
-import asyncio
-from asyncio import SelectorEventLoop, Future
-try:
-    import selectors
-except ImportError:
-    from asyncio import selectors # py33
-
-
-_aio2zmq_map = {
-    selectors.EVENT_READ: _zmq.POLLIN,
-    selectors.EVENT_WRITE: _zmq.POLLOUT,
-}
-
-_AIO_EVENTS = 0
-for aio_evt in _aio2zmq_map:
-    _AIO_EVENTS |= aio_evt
-
-def _aio2zmq(aio_evt):
-    """Turn AsyncIO event mask into ZMQ event mask"""
-    z_evt = 0
-    for aio_mask, z_mask in _aio2zmq_map.items():
-        if aio_mask & aio_evt:
-            z_evt |= z_mask
-    return z_evt
-
-def _zmq2aio(z_evt):
-    """Turn ZMQ event mask into AsyncIO event mask"""
-    aio_evt = 0
-    for aio_mask, z_mask in _aio2zmq_map.items():
-        if z_mask & z_evt:
-            aio_evt |= aio_mask
-    return aio_evt
-
-
-class _AsyncIO(object):
-    _Future = Future
-    _WRITE = selectors.EVENT_WRITE
-    _READ = selectors.EVENT_READ
-
-    def _default_loop(self):
-        return asyncio.get_event_loop()
-
-
-def _fileobj_to_fd(fileobj):
-    """Return a file descriptor from a file object.
-
-    Parameters:
-    fileobj -- file object or file descriptor
-
-    Returns:
-    corresponding file descriptor
-
-    Raises:
-    ValueError if the object is invalid
-    """
-    if isinstance(fileobj, int):
-        fd = fileobj
-    else:
-        try:
-            fd = int(fileobj.fileno())
-        except (AttributeError, TypeError, ValueError):
-            raise ValueError("Invalid file object: "
-                             "{!r}".format(fileobj)) from None
-    if fd < 0:
-        raise ValueError("Invalid file descriptor: {}".format(fd))
-    return fd
-
-
-class _SelectorMapping(Mapping):
-    """Mapping of file objects to selector keys."""
-
-    def __init__(self, selector):
-        self._selector = selector
-
-    def __len__(self):
-        return len(self._selector._fd_to_key)
-
-    def __getitem__(self, fileobj):
-        try:
-            fd = self._selector._fileobj_lookup(fileobj)
-            return self._selector._fd_to_key[fd]
-        except KeyError:
-            raise KeyError("{!r} is not registered".format(fileobj)) from None
-
-    def __iter__(self):
-        return iter(self._selector._fd_to_key)
-
-
-class ZMQSelector(selectors.BaseSelector):
-    """zmq_poll-based selector for asyncio"""
-
-    def __init__(self):
-        super().__init__()
-        # this maps file descriptors to keys
-        self._fd_to_key = {}
-        # read-only mapping returned by get_map()
-        self._map = _SelectorMapping(self)
-        self._zmq_poller = _zmq.Poller()
-
-    def _fileobj_lookup(self, fileobj):
-        """Return a zmq socket or a file descriptor from a file object.
-
-        This wraps _fileobj_to_fd() to do an exhaustive search in case
-        the object is invalid but we still have it in our map.  This
-        is used by unregister() so we can unregister an object that
-        was previously registered even if it is closed.  It is also
-        used by _SelectorMapping.
-        """
-        if isinstance(fileobj, _zmq.Socket):
-            return fileobj
-        else:
-            try:
-                return _fileobj_to_fd(fileobj)
-            except ValueError:
-                # Do an exhaustive search.
-                for key in self._fd_to_key.values():
-                    if key.fileobj is fileobj:
-                        return key.fd
-                # Raise ValueError after all.
-                raise
-
-    def register(self, fileobj, events, data=None):
-        """Register a file object.
-
-        Parameters:
-        fileobj -- zmq socket, file object or file descriptor
-        events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE)
-        data    -- attached data
-
-        Returns:
-        SelectorKey instance
-
-        Raises:
-        ValueError if events is invalid
-        KeyError if fileobj is already registered
-        OSError if fileobj is closed or otherwise is unacceptable to
-                the underlying system call (if a system call is made)
-
-        Note:
-        OSError may or may not be raised
-        """
-        if (not events) or (events & ~(selectors.EVENT_READ | selectors.EVENT_WRITE)):
-            raise ValueError("Invalid events: {!r}".format(events))
-
-        key = selectors.SelectorKey(fileobj, self._fileobj_lookup(fileobj), events, data)
-
-        if key.fd in self._fd_to_key:
-            raise KeyError("{!r} (FD {}) is already registered"
-                           .format(fileobj, key.fd))
-
-        self._fd_to_key[key.fd] = key
-
-        self._zmq_poller.register(key.fd, _aio2zmq(events))
-        return key
-
-    def unregister(self, fileobj):
-        """Unregister a file object.
-
-        Parameters:
-        fileobj -- zmq socket, file object or file descriptor
-
-        Returns:
-        SelectorKey instance
-
-        Raises:
-        KeyError if fileobj is not registered
-
-        Note:
-        If fileobj is registered but has since been closed this does
-        *not* raise OSError (even if the wrapped syscall does)
-        """
-        try:
-            key = self._fd_to_key.pop(self._fileobj_lookup(fileobj))
-        except KeyError:
-            raise KeyError("{!r} is not registered".format(fileobj)) from None
-
-        self._zmq_poller.unregister(key.fd)
-        return key
-
-    def modify(self, fileobj, events, data=None):
-        try:
-            key = self._fd_to_key[self._fileobj_lookup(fileobj)]
-        except KeyError:
-            raise KeyError("{!r} is not registered".format(fileobj)) from None
-        if events != key.events:
-            self.unregister(fileobj)
-            key = self.register(fileobj, events, data)
-        elif data != key.data:
-            # Use a shortcut to update the data.
-            key = key._replace(data=data)
-            self._fd_to_key[key.fd] = key
-        return key
-
-    def select(self, timeout=None):
-        """Perform the actual selection, until some monitored file objects are
-        ready or a timeout expires.
-
-        Parameters:
-        timeout -- if timeout > 0, this specifies the maximum wait time, in
-                   seconds
-                   if timeout <= 0, the select() call won't block, and will
-                   report the currently ready file objects
-                   if timeout is None, select() will block until a monitored
-                   file object becomes ready
-
-        Returns:
-        list of (key, events) for ready file objects
-        `events` is a bitwise mask of EVENT_READ|EVENT_WRITE
-        """
-        if timeout is not None:
-            if timeout < 0:
-                timeout = 0
-            else:
-                timeout = 1e3 * timeout
-
-        fd_event_list = self._zmq_poller.poll(timeout)
-        ready = []
-        for fd, event in fd_event_list:
-            key = self._key_from_fd(fd)
-            if key:
-                events = _zmq2aio(event)
-                ready.append((key, events))
-        return ready
-
-    def close(self):
-        """Close the selector.
-
-        This must be called to make sure that any underlying resource is freed.
-        """
-        self._fd_to_key.clear()
-        self._map = None
-        self._zmq_poller = None
-
-    def get_map(self):
-        return self._map
-
-    def _key_from_fd(self, fd):
-        """Return the key associated to a given file descriptor.
-
-        Parameters:
-        fd -- file descriptor
-
-        Returns:
-        corresponding key, or None if not found
-        """
-        try:
-            return self._fd_to_key[fd]
-        except KeyError:
-            return None
-
-
-class Poller(_AsyncIO, _future._AsyncPoller):
-    """Poller returning asyncio.Future for poll results."""
-    pass
-
-
-class Socket(_AsyncIO, _future._AsyncSocket):
-    """Socket returning asyncio Futures for send/recv/poll methods."""
-
-    _poller_class = Poller
-
-    def _add_io_state(self, state):
-        """Add io_state to poller."""
-        if not self._state & state:
-            self._state = self._state | state
-            if state & self._READ:
-                self.io_loop.add_reader(self, self._handle_recv)
-            if state & self._WRITE:
-                self.io_loop.add_writer(self, self._handle_send)
-
-    def _drop_io_state(self, state):
-        """Stop poller from watching an io_state."""
-        if self._state & state:
-            self._state = self._state & (~state)
-            if state & self._READ:
-                self.io_loop.remove_reader(self)
-            if state & self._WRITE:
-                self.io_loop.remove_writer(self)
-
-    def _init_io_state(self):
-        """initialize the ioloop event handler"""
-        pass
-
-class Context(_zmq.Context):
-    """Context for creating asyncio-compatible Sockets"""
-    _socket_class = Socket
-
-
-class ZMQEventLoop(SelectorEventLoop):
-    """AsyncIO eventloop using zmq_poll"""
-    def __init__(self, selector=None):
-        if selector is None:
-            selector = ZMQSelector()
-        return super(ZMQEventLoop, self).__init__(selector)
-
-
-_loop = None
-
-def install():
-    """Install and return the global ZMQEventLoop
-
-    registers the loop with asyncio.set_event_loop
-    """
-    global _loop
-    if _loop is None:
-        _loop = ZMQEventLoop()
-        asyncio.set_event_loop(_loop)
-    return _loop
-
-
-__all__ = [
-    'Context',
-    'Socket',
-    'Poller',
-    'ZMQEventLoop',
-    'install',
-]
diff --git a/zmq/auth/asyncio.py b/zmq/auth/asyncio.py
deleted file mode 100644
index 37fe3c5..0000000
--- zmq/auth/asyncio.py
+++ /dev/null
@@ -1,50 +0,0 @@
-"""ZAP Authenticator integrated with the asyncio IO loop.
-
-.. versionadded:: 15.2
-"""
-
-# Copyright (C) PyZMQ Developers
-# Distributed under the terms of the Modified BSD License.
-
-import asyncio
-
-import zmq
-from zmq.asyncio import Poller
-from .base import Authenticator
-
-
-class AsyncioAuthenticator(Authenticator):
-    """ZAP authentication for use in the asyncio IO loop"""
-
-    def __init__(self, context=None, loop=None):
-        super().__init__(context)
-        self.loop = loop or asyncio.get_event_loop()
-        self.__poller = None
-        self.__task = None
-
-    @asyncio.coroutine
-    def __handle_zap(self):
-        while True:
-            events = yield from self.__poller.poll()
-            if self.zap_socket in dict(events):
-                msg = yield from self.zap_socket.recv_multipart()
-                self.handle_zap_message(msg)
-
-    def start(self):
-        """Start ZAP authentication"""
-        super().start()
-        self.__poller = Poller()
-        self.__poller.register(self.zap_socket, zmq.POLLIN)
-        self.__task = asyncio.async(self.__handle_zap())
-
-    def stop(self):
-        """Stop ZAP authentication"""
-        if self.__task:
-            self.__task.cancel()
-        if self.__poller:
-            self.__poller.unregister(self.zap_socket)
-            self.__poller = None
-        super().stop()
-
-
-__all__ = ['AsyncioAuthenticator']
diff --git a/zmq/tests/_test_asyncio.py b/zmq/tests/_test_asyncio.py
deleted file mode 100644
index ad08507..0000000
--- zmq/tests/_test_asyncio.py
+++ /dev/null
@@ -1,203 +0,0 @@
-"""Test asyncio support"""
-# Copyright (c) PyZMQ Developers
-# Distributed under the terms of the Modified BSD License.
-
-import zmq
-try:
-    import asyncio
-    import zmq.asyncio as zaio
-    from zmq.auth.asyncio import AsyncioAuthenticator
-except ImportError:
-    asyncio = None
-
-from zmq.tests import BaseZMQTestCase, SkipTest
-from zmq.tests.test_auth import TestThreadAuthentication
-
-
-class TestAsyncIOSocket(BaseZMQTestCase):
-    if asyncio is not None:
-        Context = zaio.Context
-    
-    def setUp(self):
-        if asyncio is None:
-            raise SkipTest()
-        self.loop = zaio.ZMQEventLoop()
-        asyncio.set_event_loop(self.loop)
-        super(TestAsyncIOSocket, self).setUp()
-    
-    def tearDown(self):
-        self.loop.close()
-        super().tearDown()
-    
-    def test_socket_class(self):
-        s = self.context.socket(zmq.PUSH)
-        assert isinstance(s, zaio.Socket)
-        s.close()
-    
-    def test_recv_multipart(self):
-        @asyncio.coroutine
-        def test():
-            a, b = self.create_bound_pair(zmq.PUSH, zmq.PULL)
-            f = b.recv_multipart()
-            assert not f.done()
-            yield from a.send(b'hi')
-            recvd = yield from f
-            self.assertEqual(recvd, [b'hi'])
-        self.loop.run_until_complete(test())
-
-    def test_recv(self):
-        @asyncio.coroutine
-        def test():
-            a, b = self.create_bound_pair(zmq.PUSH, zmq.PULL)
-            f1 = b.recv()
-            f2 = b.recv()
-            assert not f1.done()
-            assert not f2.done()
-            yield from  a.send_multipart([b'hi', b'there'])
-            recvd = yield from f2
-            assert f1.done()
-            self.assertEqual(f1.result(), b'hi')
-            self.assertEqual(recvd, b'there')
-        self.loop.run_until_complete(test())
-
-    def test_recv_dontwait(self):
-        @asyncio.coroutine
-        def test():
-            push, pull = self.create_bound_pair(zmq.PUSH, zmq.PULL)
-            f = pull.recv(zmq.DONTWAIT)
-            with self.assertRaises(zmq.Again):
-                yield from f
-            yield from push.send(b'ping')
-            yield from pull.poll() # ensure message will be waiting
-            f = pull.recv(zmq.DONTWAIT)
-            assert f.done()
-            msg = yield from f
-            self.assertEqual(msg, b'ping')
-        self.loop.run_until_complete(test())
-
-    def test_recv_cancel(self):
-        @asyncio.coroutine
-        def test():
-            a, b = self.create_bound_pair(zmq.PUSH, zmq.PULL)
-            f1 = b.recv()
-            f2 = b.recv_multipart()
-            assert f1.cancel()
-            assert f1.done()
-            assert not f2.done()
-            yield from a.send_multipart([b'hi', b'there'])
-            recvd = yield from f2
-            assert f1.cancelled()
-            assert f2.done()
-            self.assertEqual(recvd, [b'hi', b'there'])
-        self.loop.run_until_complete(test())
-
-    def test_poll(self):
-        @asyncio.coroutine
-        def test():
-            a, b = self.create_bound_pair(zmq.PUSH, zmq.PULL)
-            f = b.poll(timeout=0)
-            yield from asyncio.sleep(0)
-            self.assertEqual(f.result(), 0)
-        
-            f = b.poll(timeout=1)
-            assert not f.done()
-            evt = yield from f
-            
-            self.assertEqual(evt, 0)
-        
-            f = b.poll(timeout=1000)
-            assert not f.done()
-            yield from a.send_multipart([b'hi', b'there'])
-            evt = yield from f
-            self.assertEqual(evt, zmq.POLLIN)
-            recvd = yield from b.recv_multipart()
-            self.assertEqual(recvd, [b'hi', b'there'])
-        self.loop.run_until_complete(test())
-    
-    def test_aiohttp(self):
-        try:
-            import aiohttp
-        except ImportError:
-            raise SkipTest("Requires aiohttp")
-        from aiohttp import web
-        
-        zmq.asyncio.install()
-        
-        @asyncio.coroutine
-        def echo(request):
-            print(request.path)
-            return web.Response(body=str(request).encode('utf8'))
-        
-        @asyncio.coroutine
-        def server(loop):
-            app = web.Application(loop=loop)
-            app.router.add_route('GET', '/', echo)
-
-            srv = yield from loop.create_server(app.make_handler(),
-                                                '127.0.0.1', 8080)
-            print("Server started at http://127.0.0.1:8080")
-            return srv
-
-        @asyncio.coroutine
-        def client():
-            push, pull = self.create_bound_pair(zmq.PUSH, zmq.PULL)
-            
-            res = yield from aiohttp.request('GET', 'http://127.0.0.1:8080/')
-            text = yield from res.text()
-            yield from push.send(text.encode('utf8'))
-            rcvd = yield from pull.recv()
-            self.assertEqual(rcvd.decode('utf8'), text)
-
-        loop = asyncio.get_event_loop()
-        loop.run_until_complete(server(loop))
-        print("servered")
-        loop.run_until_complete(client())
-
-
-class TestAsyncioAuthentication(TestThreadAuthentication):
-    """Test authentication running in a asyncio task"""
-
-    if asyncio is not None:
-        Context = zaio.Context
-
-    def shortDescription(self):
-        """Rewrite doc strings from TestThreadAuthentication from
-        'threaded' to 'asyncio'.
-        """
-        doc = self._testMethodDoc
-        if doc:
-            doc = doc.split("\n")[0].strip()
-            if doc.startswith('threaded auth'):
-                doc = doc.replace('threaded auth', 'asyncio auth')
-        return doc
-
-    def setUp(self):
-        if asyncio is None:
-            raise SkipTest()
-        self.loop = zaio.ZMQEventLoop()
-        asyncio.set_event_loop(self.loop)
-        super().setUp()
-
-    def tearDown(self):
-        super().tearDown()
-        self.loop.close()
-
-    def make_auth(self):
-        return AsyncioAuthenticator(self.context)
-
-    def can_connect(self, server, client):
-        """Check if client can connect to server using tcp transport"""
-        @asyncio.coroutine
-        def go():
-            result = False
-            iface = 'tcp://127.0.0.1'
-            port = server.bind_to_random_port(iface)
-            client.connect("%s:%i" % (iface, port))
-            msg = [b"Hello World"]
-            yield from server.send_multipart(msg)
-            if (yield from client.poll(1000)):
-                rcvd_msg = yield from client.recv_multipart()
-                self.assertEqual(rcvd_msg, msg)
-                result = True
-            return result
-        return self.loop.run_until_complete(go())
diff --git a/zmq/tests/test_asyncio.py b/zmq/tests/test_asyncio.py
deleted file mode 100644
index 49a41ad..0000000
--- zmq/tests/test_asyncio.py
+++ /dev/null
@@ -1,6 +0,0 @@
-"""Test asyncio support"""
-
-try:
-    from ._test_asyncio import TestAsyncIOSocket, TestAsyncioAuthentication
-except SyntaxError:
-    pass
-- 
2.9.2

